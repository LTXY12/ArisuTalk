# 🚨 **긴급: SNS/NAI 시스템 복구 전략 (2025년 1월)**

## **현재 상황 분석**
- **원래**: upstream/main PR#28 병합으로 SNS/NAI 기능 손실
- **문제**: 병합 과정에서 커스텀 SNS/NAI 시스템이 누락됨
- **과제**: full 백업에서 SNS/NAI 기능을 현재 시스템에 호환성 있게 복구

## **⚠️ 핵심 복구 원칙**
1. **full 백업을 기준으로 기능 확인 및 복구**
2. **현재 시스템과 호환성 있게 적용**
3. **필요한 파일은 백업에서 가져오기**
4. **불확실한 사항은 사용자 확인 후 진행**
5. **단계별 검증을 통한 안정적 복구**
6. **📋 Phase 완료 후 필수 중단: 각 Phase가 완료되면 반드시 응답을 종료하고 다음 수정을 위한 검토 필요**
7. **🚨 백업 파일 보호 정책: 백업 파일들이 삭제되지 않게 주의하며 진행**
8. **✅ git 충돌 마커 상태: <<<<<<< HEAD, >>>>>>> upstream/main, ======= 등의 git 충돌 마커는 현재 모든 파일에서 완전히 제거된 상태임. 절대로 찾으려 시도하지 말 것!**

---

## **🔧 SNS/NAI 복구 전략 (단계별 실행 계획)**

### **Phase 1: 백업 분석 및 누락 파일 식별**
1. **full 백업 내 SNS/NAI 관련 파일 목록 확인**
2. **현재 시스템과 비교하여 누락된 파일들 식별**
3. **각 파일의 기능과 의존관계 분석**
4. **복구 우선순위 결정**

### **Phase 2: 핵심 파일 복구**
1. **SNS 관련 컴포넌트 파일들 복구**
2. **NAI 관련 API 및 설정 파일들 복구**
3. **핸들러 파일들 복구 및 현재 시스템 연결**
4. **유틸리티 및 지원 파일들 복구**

### **Phase 3: 상태 구조 통합**
1. **백업의 상태 구조 분석**
2. **현재 시스템의 상태 구조와 비교**
3. **호환성을 위한 상태 구조 조정**
4. **저장/불러오기 시스템 연결**

### **Phase 4: 이벤트 연결 및 핸들러 통합**
1. **SNS 버튼 클릭 이벤트 연결**
2. **모달 핸들러 통합 및 수정**
3. **NAI 설정 이벤트 연결**
4. **전체 이벤트 체계 검증**

### **Phase 5: UI 통합 및 렌더링**
1. **모달 렌더링 시스템 통합**
2. **UI 컴포넌트 호환성 조정**
3. **스타일링 및 레이아웃 통합**
4. **반응형 디자인 호환성 확인**

### **Phase 6: 기능 테스트 및 검증**
1. **SNS 전체 워크플로우 테스트**
2. **NAI 스티커 생성 시스템 테스트**
3. **최면 제어 시스템 테스트**
4. **전체 시스템 통합 테스트**

---

## **📋 upstream/main 주요 변경사항 (PR #28)**

### **1. 모바일 UI 대규모 개편**
- **MobileSettingsModal.js → MobileSettingsUI.js** 변경
- **새로운 모바일 페이지 전환 시스템** 도입
- **SettingsRouter.js** 새로운 설정 라우팅 시스템
- **CharacterListPage.js** 새로운 캐릭터 목록 페이지
- **SearchModal.js** 새로운 검색 모달

### **2. UI 렌더링 시스템 변경**
- **ui.js**: 모바일/데스크톱 분리된 렌더링 로직
- **page-transition-container** 기반 애니메이션 시스템
- **conditional blur** 및 **adjustMessageContainerPadding** 시스템

### **3. 상태 관리 변경**
- **expandedCharacterId** → **expandedCharacterIds** (Set으로 변경)
- **새로운 모바일 상태들**: `showAiSettingsUI`, `showScaleSettingsUI`, `showMobileSearch` 등
- **모달 구조 개편**: main modal과 confirmation modal 분리

---

## **🎯 우리 브랜치의 보존해야 할 커스텀 기능**

**상세 정보는 별도 문서를 참조하세요:**
👉 **[CUSTOM_FEATURES.md](docs/CUSTOM_FEATURES.md)** - 커스텀 기능 상세 가이드

# **➡️ 전체 세부사항은 별도 문서 참조**

---

## **🔧 병합 전략 (단계별 실행 계획)**

**상세 병합 전략은 별도 문서를 참조하세요:**
👉 **[MERGE_STRATEGY.md](docs/MERGE_STRATEGY.md)** - 단계별 병합 실행 계획

# **➡️ 전체 세부사항은 별도 문서 참조**

---

# ArisuTalk 프로젝트 개발 지침

## 🌐 언어 및 커뮤니케이션 설정

### **필수: 한국어 사용 원칙**
- **모든 대화와 응답은 한국어로 진행**
- **코드 주석, 변수명, 함수명 등은 기존 프로젝트 규칙 따름** (영어/한국어 혼용)
- **사용자와의 모든 커뮤니케이션은 반드시 한국어로**
- **에러 메시지나 설명도 한국어로 제공**
- **기술적 용어는 한국어 우선, 필요시 영어 병기 (예: "컴포넌트(component)")**

### **커뮤니케이션 스타일**
- **간결하고 명확한 한국어 사용**
- **존댓말 사용 (높임말)**
- **기술적 설명도 이해하기 쉬운 한국어로**

## ✅ **완료된 작업 내역 (2024년 9월)**

### **🎯 SNS 4-Tier Permission System 완료**
- **✅ 호감도 기반 캐릭터 상태 시스템 구현** - affection/intimacy/trust/romantic_interest 4단계
- **✅ 최면 제어 시스템 완료** - UI 초기화, 데이터 저장, 실시간 반영 문제 해결
- **✅ SNS UI 구조 변경 완료** - 게시물/비밀글/태그 탭으로 개편
- **✅ AI 응답 reason 필드 추가** - 호감도 변화 이유 설명 기능
- **✅ 다국어 지원(i18n) 통합** - 모든 SNS 관련 텍스트 국제화
- **✅ 4단계 접근 권한 시스템** - 본계정 공개/비공개, 뒷계정 공개/비공개
- **✅ 듀얼 계정 시스템** - 본계정(회색)/뒷계정(붉은) 테마 구분
- **✅ 프로젝트 정리** - 불필요한 백업 파일 및 임시 파일 제거

### **🎨 SNS 스티커 시스템 개선 (2025년 1월 완료)**
- **✅ 스티커 파싱 실패 방지** - 10개 초과 태그 자동 제한 시스템 구현
- **✅ AI 스티커 사용 개선** - 자연스러운 감정 기반 스티커 선택 프롬프트 적용
- **✅ 스티커 ID 호환성 해결** - 문자열/숫자 타입 호환 처리 완료
- **✅ SNS 스티커 크기 최적화** - UI 크기에 맞는 반응형 스티커 표시
- **✅ 디버깅 시스템 강화** - SNS 생성 과정 전체 추적 로그 구현

### **🚨 최근 작업 중 반복된 실수 및 주의사항 (2025년 1월 추가)**

#### **0. 명령 해석 실수 방지 (최우선!!!)**
- **❌❌❌ 사용자가 A를 요청했는데 B를 수정하는 실수**
- **❌ "설정 모달"을 수정하라고 했는데 "캐릭터 모달" 수정**
- **❌ UI 변경하지 말라고 했는데 UI 변경**
- **✅ 명령을 정확히 이해하고 확인 후 작업**
- **✅ 파일명과 위치 명확히 구분 (Settings vs Character Modal)**

#### **1. defaults.js 사용 금지**
- **❌ 절대 defaults.js에 새로운 기본값 추가 금지**
- **✅ 기본값은 각 컴포넌트나 서비스 내부에서 직접 관리**
- **이유**: 프로젝트 구조상 defaults.js는 레거시이며 새로운 기능은 사용하지 않음

#### **2. 외부 창/알림 사용 금지**
- **❌ window.open(), alert(), confirm() 등 브라우저 창/알림 사용 금지**
- **✅ 모든 UI는 내부 모달이나 컴포넌트로 표시**
- **예시**: 이미지 결과는 ImageResultModal 컴포넌트 사용

#### **3. 하드코딩된 기본값 주의**
- **❌ API 호출 시 하드코딩된 모델명이나 설정값 사용 금지**
- **✅ 설정 우선순위: 캐릭터별 설정 → 전역 설정 → 코드 내 기본값**
- **예시**: NAI 모델은 character.naiSettings.model 우선 사용

#### **4. 상태 저장 누락 방지 (매우 중요!!!)**
- **체크리스트 필수 확인**:
  - [ ] loadFromBrowserStorage()에 새 키 추가
  - [ ] this.state에 할당
  - [ ] debouncedSave 메서드 정의
  - [ ] setState()에 변경 감지 추가
  - [ ] storage.js의 appKeys에 키 추가
  
- **중첩된 객체 저장 문제**:
  - **❌ settings.naiSettings 같은 중첩 객체는 JSON.stringify 비교로 감지 안됨**
  - **✅ setState()에서 settings 전체를 비교하도록 구현**
  - **✅ 또는 naiSettings 변경 시 settings 전체를 새 객체로 생성**

#### **5. 이벤트 핸들러 중복 방지**
- **❌ onclick 속성과 addEventListener 중복 사용 금지**
- **✅ 하나의 방식으로 통일 (addEventListener 권장)**
- **✅ 아이콘 요소에 pointer-events-none 클래스 필수**

#### **6. 함수 누락 방지**
- **❌ 존재하지 않는 함수 호출 (예: this.showModal)**
- **✅ 함수 구현 전 grep으로 중복 확인**
- **✅ import/export 일치 확인**

#### **7. 모달 표시 및 이벤트 처리 (중요)**
- **❌ 모달 내 버튼 이벤트 리스너 누락**
- **❌ 동적으로 생성된 요소에 이벤트 바인딩 안함**
- **❌ z-index 고려 안함 (모달이 다른 모달 뒤에 가려짐)**
- **❌❌❌ shouldUpdateModals()에 새 모달 상태 체크 누락 (가장 중요!)**
- **✅ ui.js의 shouldUpdateModals()에 모든 모달 상태 추가 필수**
- **✅ ui.js의 renderModals()에서 이벤트 리스너 설정**
- **✅ requestAnimationFrame()으로 DOM 업데이트 보장**
- **✅ z-index 계층 관리: 일반 모달(z-50) < 중요 모달(z-[9999])**

**모달 z-index 계층:**
- z-50: 일반 모달 (CharacterModal, SettingsModal 등)
- z-[9999]: 최상위 모달 (ImageResultModal, ConfirmationModal 등)

#### **8. 상태 업데이트 실시간 반영 (올바른 패턴)**
- **❌ setState() 후 UI가 업데이트 안되는 문제**
- **❌ 비동기 작업 완료 후 UI 업데이트 누락**
- **❌ setTimeout으로 이벤트 리스너 설정 (안티패턴)**
- **✅ setState() 호출로 자동 UI 업데이트 유도**
- **✅ ui.js의 renderModals()에서 이벤트 리스너 자동 설정**
- **✅ requestAnimationFrame()으로 DOM 업데이트 보장**

**올바른 모달 구현 패턴 (필수 준수):**
```javascript
// 1. index.js - 모달 표시 함수
showImageResultModal(imageUrl, promptText) {
  this.setState({
    imageResultModal: {
      isOpen: true,
      imageUrl: imageUrl,
      promptText: promptText
    }
  });
  // setState가 자동으로 UI 업데이트 트리거
}

// 2. ui.js - shouldUpdateModals에 상태 체크 추가 (필수!)
function shouldUpdateModals(oldState, newState) {
  return (
    // ... 기존 모달들 ...
    // 새 모달 상태 체크 반드시 추가!
    JSON.stringify(oldState.imageResultModal) !== JSON.stringify(newState.imageResultModal) ||
    // ... 나머지 체크들 ...
  );
}

// 3. ui.js - 모달 렌더링 및 이벤트 설정
async function renderModals(app) {
  const container = document.getElementById("modal-container");
  let html = "";
  
  // 모달 HTML 추가
  if (app.state.imageResultModal && app.state.imageResultModal.isOpen) {
    html += renderImageResultModal(app.state.imageResultModal);
  }
  
  container.innerHTML = html;
  
  // DOM 업데이트 후 이벤트 리스너 설정
  if (app.state.imageResultModal && app.state.imageResultModal.isOpen) {
    requestAnimationFrame(() => {
      app.setupImageResultModalEvents();
    });
  }
}

// 4. 모달 컴포넌트 - z-index 설정 필수
<div class="... z-[9999] ..."> <!-- 다른 모달 위에 표시 -->
```

### **⚠️ 향후 개발 시 중요한 충돌 방지 지침**

#### **1. i18n 충돌 해결**
- **모든 하드코딩된 한국어 텍스트를 i18n 키로 변환**
- **`t('sns.키명')` 형태로 다국어 지원**
- **기존 최신 코드의 i18n 패턴 엄격히 준수**

#### **2. 최신 코드베이스 호환성**
- **기존 API 시스템 변경사항 반영**
- **IndexedDB 저장 시스템 활용** 
- **기존 이벤트 핸들링 패턴 유지**
- **모듈화된 컴포넌트 구조 준수**

#### **3. PR 피드백 반영**
- **완전한 기능 구현 후 제출**
- **모든 버튼과 이벤트 완전 연결**
- **실제 동작 테스트 완료 후 커밋**
- **중복 코드 제거 및 정리**

#### **4. characterState 시스템 (완전 대체 완료)**
- **4가지 호감도 지표**: affection/intimacy/trust/romantic_interest + reason
- **기존 mood/energy/socialBattery/personality 시스템은 완전히 대체됨**
- **모든 캐릭터 상태 관리가 호감도 기반으로 변경됨**

#### **5. 저장소 시스템 보존**
- **IndexedDB 마이그레이션 완료된 상태 유지**
- **기존 저장 구조와 키 패턴 엄격히 준수**
- **새로운 데이터도 기존 IndexedDB 패턴 따라 저장**

#### **6. UI 클릭 이벤트 및 버튼 동작 완전성**
- **이벤트 방식 통일**: onclick 속성과 이벤트 핸들러 중복 사용 금지
- **아이콘 이벤트 차단**: 모든 아이콘에 `pointer-events-none` 클래스 필수 추가
- **클릭 영역 확보**: 적절한 padding(최소 p-2) 및 높은 z-index(z-20) 설정
- **이벤트 핸들러 연결**: 해당 핸들러 파일에 올바른 선택자로 이벤트 리스너 추가
- **메서드 존재 확인**: 호출하는 메서드가 실제로 정의되어 있는지 확인
- **중복 구현 제거**: 같은 기능이 여러 파일에 중복 구현되지 않았는지 확인

#### **7. 데이터 저장/불러오기 완전성 점검**
- **초기 로딩**: `loadAllData()` 함수에서 `loadFromBrowserStorage` 호출 추가
- **상태 할당**: 불러온 데이터를 `this.state.{속성명}`에 할당
- **자동 저장**: `setState()`에서 변경 감지 및 debounced 저장 메서드 호출
- **저장 메서드 정의**: constructor에서 `this.debouncedSave{속성명}` 메서드 정의
- **UI 업데이트 감지**: `shouldUpdateSidebar()` 등 UI 업데이트 조건에 상태 추가
- **storage.js 키 목록**: `getLocalStorageUsage()` 함수의 `appKeys` 배열에 키 추가

#### **8. 실시간 UI 업데이트 시스템**
- **상태 변경 감지**: `setState()` 메서드를 통한 모든 상태 변경 관리
- **UI 렌더링 조건**: `shouldUpdateSidebar()`, `shouldUpdateMainChat()` 등 조건 체크
- **debounced 저장**: 빈번한 상태 변경 시 성능 최적화를 위한 debounced 저장
- **모달 상태 유지**: 모달 렌더링 시 기존 상태 보존 (특히 최면 제어 시스템)
- **실시간 반영**: 캐릭터 상태 변경이 즉시 UI에 반영되도록 보장

#### **9. 새로운 기능 추가 시 필수 체크리스트**
**새로운 상태 추가 시:**
- [ ] `loadFromBrowserStorage("personaChat_newState_v16", {})` 추가
- [ ] `this.state.newState = newState;` 상태 할당 추가  
- [ ] `this.debouncedSaveNewState = debounce(...)` 저장 메서드 정의
- [ ] `setState()`에 변경 감지 및 저장 호출 추가
- [ ] UI 렌더링 조건에 `newState` 변경 감지 추가
- [ ] `storage.js`의 `appKeys` 배열에 키 추가

**새로운 버튼 추가 시:**
- [ ] HTML에서 onclick 속성 제거, id나 class로만 식별
- [ ] 버튼 내부 아이콘에 `pointer-events-none` 추가
- [ ] 적절한 padding과 z-index 설정 (`p-2`, `z-20`)
- [ ] 해당 이벤트 핸들러 파일에서 `e.target.closest()` 선택자 추가
- [ ] 호출하는 메서드가 `index.js`에 정의되어 있는지 확인
- [ ] 같은 기능이 다른 파일에 중복 구현되지 않았는지 확인

**새로운 함수 구현 시:**
- [ ] `grep -r "functionName" src/` 로 중복 구현 검색
- [ ] export/import 문 정확성 확인
- [ ] 호출하는 모든 메서드가 실제로 존재하는지 확인
- [ ] 같은 기능의 다른 구현체 제거 완료
- [ ] 사용하지 않는 import 정리 완료

**기능 완성 후 필수 테스트:**
- [ ] 브라우저 개발자 도구에서 오류 없음 확인
- [ ] 모든 버튼 실제 클릭해서 동작 확인
- [ ] 페이지 새로고침 후 데이터 유지 확인
- [ ] 전체 기능 플로우 처음부터 끝까지 테스트 완료

### **📱 구현된 핵심 시스템 (요약)**

#### **1. SNS 4-Tier 접근 권한 시스템**
- **본계정 공개**: 무제한 접근
- **본계정 비공개**: 호감도 중 하나라도 70% 이상
- **뒷계정 공개**: 모든 호감도 최대치 또는 최면 권한
- **뒷계정 비공개**: 뒷계정 접근 + 특별 조건

#### **2. 호감도 기반 캐릭터 상태 시스템**
```javascript
characterState: {
    affection: 0.3,        // 기본 호감도
    intimacy: 0.1,         // 친밀도
    trust: 0.2,            // 신뢰도
    romantic_interest: 0.0, // 로맨틱 관심도
    reason: "변화 이유 설명" // 변화 사유
}
```

#### **3. 최면 제어 시스템**
- 호감도 강제 설정, SNS 접근 권한 강제 부여
- UI 초기화 문제 해결: modalHandlers.js에서 character modal 제외

#### **4. 다국어 지원 (i18n)**
- 모든 SNS 텍스트 `t('sns.키명')` 형태로 관리
- language/ko.js, language/en.js에서 통합 관리

### **⚠️ 구현 시 주의사항**

#### **1. i18n 충돌 해결**
- **모든 하드코딩된 한국어 텍스트를 i18n 키로 변환**
- **`t('sns.키명')` 형태로 다국어 지원**
- **기존 최신 코드의 i18n 패턴 엄격히 준수**

#### **2. 최신 코드베이스 호환성**
- **기존 API 시스템 변경사항 반영**
- **IndexedDB 저장 시스템 활용** 
- **기존 이벤트 핸들링 패턴 유지**
- **모듈화된 컴포넌트 구조 준수**

#### **3. PR #9 피드백 반영**
- **완전한 기능 구현 후 제출**
- **모든 버튼과 이벤트 완전 연결**
- **실제 동작 테스트 완료 후 커밋**
- **중복 코드 제거 및 정리**

### **🎯 SNS 4-Tier Permission System 구현 완료**
모든 기능이 완전히 구현되어 사용자가 캐릭터와의 관계 깊이에 따라 점진적으로 더 깊은 콘텐츠에 접근할 수 있는 시스템이 완성되었습니다.

---

## 프로젝트 개요

ArisuTalk은 AI 캐릭터와의 고도화된 인터랙션을 제공하는 차세대 채팅 애플리케이션입니다. 기존의 단순한 채팅을 넘어 SNS, 현실 만남, 호감도 시스템 등을 통합한 종합적인 캐릭터 상호작용 플랫폼으로 발전하고 있습니다.

## 🎉 현재 프로젝트 상태 (2024년 8월 완료)

### ✅ 완료된 주요 기능들
1. **✅ API 다분화 완료** - 6개 프로바이더 지원 (Gemini, Claude, OpenAI, Grok, OpenRouter, Custom OpenAI)
2. **✅ 단톡방/오픈톡방 시스템 구현 완료** - 다중 캐릭터 대화, 동적 참여자 관리
3. **✅ AI 캐릭터 생성 기능 완료** - 사용자 설명 기반 자동 생성
4. **✅ 저장소 시스템 대폭 개선** - IndexedDB 도입으로 용량 제한 해결
5. **✅ 시스템 디버그 로그 완료** - 실시간 모니터링 및 에러 추적
6. **✅ 페르소나 스티커 시스템 수정** - API 키 오류 해결, 안정성 향상
7. **✅ 캐릭터 내보내기 개선** - 스티커 포함 지원
8. **✅ 각종 UI/UX 버그 수정** - 버튼 이벤트, 클릭 오류 등 전면 개선

### 🚀 Pull Request 완료
- **브랜치**: `fix/persona-sticker-api-key-issue`
- **상태**: 원본 저장소로 PR 제출 완료
- **내용**: 대규모 기능 확장 및 시스템 개선

## 🎯 차세대 개발 목표 (Next Phase)

**현재 기본 채팅 시스템이 완성됨에 따라, 보다 몰입감 있는 캐릭터 인터랙션 시스템으로 진화**

### 🎨 **Phase 2.5: NAI 이미지 생성 기반 스티커 자동 생성 시스템 (진행 예정)**

#### **개요**
NovelAI의 Persistent API Token을 활용하여 캐릭터별 감정과 상황에 맞는 스티커를 자동으로 생성하는 시스템 구현

#### **1. NAI API 통합**
- **목표**: NovelAI Diffusion 4.5 Curated Preview 모델 활용
- **구현 위치**: `src/api/novelai.js`
- **주요 기능**:
  - Persistent API Token 기반 인증 시스템
  - 감정별 프롬프트 템플릿 (happy, sad, surprised, angry, love, etc.)
  - Prefix + 감정상황 + Quality 프롬프트 자동 구성
  - Negative 프롬프트를 통한 품질 제어
  - Vibe Image를 통한 캐릭터 일관성 유지

#### **2. 감정 기반 스티커 생성**
- **감정 인식**: 대화 내용 및 SNS 포스트에서 자동 감정 분석
- **프롬프트 구조**: 
  ```
  [캐릭터 특징] + [감정 키워드] + [스티커 스타일] + [품질 태그]
  ```
- **자동 생성 트리거**:
  - SNS 포스트 작성 시 해당 감정 스티커가 없는 경우
  - 사용자 요청에 의한 일괄 감정 스티커 생성
  - 새 캐릭터 생성 시 기본 감정 세트 자동 생성

#### **3. 설정 및 UI 통합**
- **설정 패널**: Settings Modal에 NAI API 키 입력 및 자동 생성 옵션 추가
- **생성 옵션**:
  - 자동 스티커 생성 on/off
  - Vibe Image 사용 여부
  - 생성 품질 설정 (steps, scale 조절)
- **배치 생성**: 모든 캐릭터 또는 선택 캐릭터의 기본 감정 스티커 일괄 생성

#### **4. 데이터 구조 확장**
```javascript
// 캐릭터 데이터 구조에 추가
character: {
  // ... 기존 필드들
  naiSettings: {
    vibeImage: "base64_image_data", // 캐릭터 일관성을 위한 참조 이미지
    autoGenerate: true,             // 자동 생성 여부
    lastGenerated: timestamp,       // 마지막 생성 시간
    nextGenerationTime: timestamp,  // 다음 생성 가능 시간 (20~30초 대기)
    generatedEmotions: ["happy", "sad", "surprised"], // 생성된 감정 목록
    preferredSize: "square"         // square(1024×1024) | portrait(832×1216) | landscape(1216×832)
  },
  stickers: [
    {
      id: "generated_happy_123",
      name: "Happy Expression",
      type: "image/png",
      dataUrl: "data:image/png;base64,..",
      emotion: "happy",        // 감정 태그
      generated: true,         // 자동 생성 표시
      naiPrompt: "original prompt used", // 생성에 사용된 프롬프트 보관
      naiSize: "1024x1024",    // 생성 시 사용된 크기 (무제한 사용 확인용)
      timestamp: Date.now()
    }
  ]
}

// NAI API 생성 대기 시간 관리
const NAI_GENERATION_CONFIG = {
  MIN_DELAY: 20000,           // 최소 20초
  MAX_ADDITIONAL_DELAY: 10000, // 추가 0~10초 랜덤
  UNLIMITED_SIZES: [
    { width: 832, height: 1216, name: "portrait" },   // Normal Portrait
    { width: 1216, height: 832, name: "landscape" },  // Normal Landscape  
    { width: 1024, height: 1024, name: "square" }     // Normal Square
  ]
}
```

#### **5. 구현 우선순위**
1. **NAI API 모듈 구현** - 기본 이미지 생성 API 연동 및 무제한 사이즈 설정
2. **안전 사용 시스템** - 20~30초 랜덤 대기시간 및 부정사용 방지 로직
3. **감정별 프롬프트 시스템** - 10가지 기본 감정 템플릿 구성  
4. **설정 UI 추가** - API 키 입력 및 생성 옵션 설정
5. **자동 생성 로직** - SNS 포스트 시 감정 분석 및 스티커 생성
6. **배치 생성 시스템** - 기존 캐릭터 대상 일괄 스티커 생성 (안전 대기시간 포함)
7. **품질 최적화** - 프롬프트 튜닝 및 결과 품질 향상

#### **6. 기술적 고려사항**
- **무제한 사용 조건**: NAI 기본 3가지 사이즈 사용 시 무제한 생성 가능
  - Normal Portrait: `832 × 1216`
  - Normal Landscape: `1216 × 832` 
  - Normal Square: `1024 × 1024`
- **안전한 사용을 위한 제한**: 연속 생성 시 부정사용 방지
  - **최소 대기시간**: 20초 + 0~10초 랜덤 추가 시간
  - **예시**: 21초 → 24초 → 27초 → 22초 (매번 랜덤 변경)
- **성능 최적화**: 비동기 처리 및 사용자 경험 향상
- **에러 처리**: API 실패 시 대체 동작 및 사용자 알림
- **저장소 관리**: 생성된 이미지의 효율적인 IndexedDB 저장

### 🌟 Phase 3: 소셜 미디어 통합 시스템

#### 1. 캐릭터별 개인 SNS 시스템
**목표**: Instagram과 유사한 캐릭터 전용 SNS 플랫폼 구현

##### 📱 본계 (공개 계정)
- **기능**: 모든 사용자에게 개방된 SNS 피드
- **콘텐츠**: 캐릭터의 일상 공유, 일반적인 생각과 경험
- **상호작용**: 
  - 모든 캐릭터들이 서로 댓글/좋아요 가능
  - 사용자도 댓글/좋아요 참여 가능
  - 캐릭터 간 자연스러운 소셜 네트워킹
- **UI**: Instagram 스타일의 피드 디자인
- **AI 로직**: 각 캐릭터의 성격에 맞는 일상 포스팅 자동 생성

##### 🔒 뒷계 (비공개/친밀 계정)  
- **기능**: 호감도 기반 제한적 접근 시스템
- **콘텐츠**: 
  - 지극히 개인적이고 은밀한 내용
  - 성적 욕구, 자위 일기, 개인적 성향 등
  - 감정의 깊은 내면, 비밀스러운 생각
- **접근 제어**:
  - **기본**: 사용자 접근 불가
  - **호감도 조건**: 일정 호감도 이상 달성 시 열람 가능
  - **수동 설정**: 캐릭터 설정에서 강제 조절 가능
- **UI**: 더 사적이고 친밀한 디자인 테마
- **AI 로직**: 캐릭터의 내밀한 면을 표현하는 고도화된 프롬프팅

#### 2. 호감도 연동 시스템
- **호감도 계산**: 채팅 내용, 선택지 반응, 상호작용 빈도 기반
- **단계별 콘텐츠 해금**: 호감도 구간별 차별화된 콘텐츠 제공
- **실시간 반영**: 채팅에서의 관계 변화가 SNS에 즉시 반영

### 🎮 Phase 4: 현실 만남 시뮬레이션 시스템

#### 1. 미연시 스타일 만남 시스템
**목표**: 채팅을 넘어선 실제 만남 체험 제공

##### 📅 약속 잡기 시스템
- **UI**: 캘린더 및 장소 선택 인터페이스
- **조건**: 호감도 기반 만남 가능 여부 결정
- **장소**: 다양한 데이트 스팟 (카페, 공원, 영화관, 레스토랑 등)
- **시간**: 시간대별 다른 분위기와 대화 주제

##### 🎯 선택지 기반 인터랙션
- **자동 발동**: AI가 특별한 상황 판단 시 선택지 시스템 활성화
- **상황 예시**:
  - 갑작스러운 비가 올 때의 대처
  - 캐릭터의 감정적 순간 포착
  - 로맨틱한 분위기 조성 시점
  - 갈등 상황 발생 시
- **결과 시스템**:
  - **적절한 선택**: 호감도 상승, 긍정적 반응
  - **부적절한 선택**: 호감도 하락, 관계 악화
- **AI 판단**: GPT가 상황의 특별함을 자체 판단하여 선택지 발동

##### 🎨 전용 UI 디자인
- **만남 모드**: 채팅과 구분되는 독립적인 UI
- **배경**: 선택한 장소에 맞는 시각적 배경
- **캐릭터 표현**: 상황에 맞는 캐릭터 일러스트/아바타
- **분위기 연출**: 시간대, 날씨, 상황에 따른 동적 UI 변화

#### 2. 호감도 연동 제한 시스템
- **최소 호감도**: 만남 기능 사용을 위한 임계점 설정
- **점진적 해금**: 호감도 상승에 따른 만남 장소/활동 확장
- **관리자 권한**: 설정에서 호감도 요구사항 강제 조절 가능

## 현재 프로젝트 구조 (2024년 8월 업데이트됨)

### 완성된 구조 (모듈화 + 대규모 확장)
```
frontend/src/
├── api/                    # 다중 API 프로바이더 시스템
│   ├── apiManager.js      # 통합 API 관리자
│   ├── claude.js          # Anthropic Claude API
│   ├── customopenai.js    # Custom OpenAI 호환 API
│   ├── gemini.js          # Google Gemini API
│   ├── grok.js            # xAI Grok API
│   ├── openai.js          # OpenAI API
│   ├── openrouter.js      # OpenRouter API
│   ├── promptBuilder.js   # 프롬프트 빌더
│   └── prompts.js         # 프롬프트 템플릿
├── components/             # UI 컴포넌트 (확장됨)
│   ├── Avatar.js
│   ├── CharacterModal.js  # AI 생성 기능 추가
│   ├── ConfirmationModal.js
│   ├── DebugLogsModal.js  # 새로운 디버그 모달
│   ├── GroupChat.js       # 새로운 단톡방 컴포넌트
│   ├── MainChat.js        # 페르소나 스티커 시스템 개선
│   ├── PromptModal.js
│   ├── SettingsModal.js   # API 설정 다분화
│   └── Sidebar.js
├── handlers/               # 이벤트 핸들러 (확장됨)
│   ├── groupChatHandlers.js  # 새로운 단톡방 핸들러
│   ├── mainChatHandlers.js
│   ├── modalHandlers.js
│   └── sidebarHandlers.js
├── defauts.js             # 확장된 기본 설정
├── index.js               # 메인 애플리케이션 (대폭 개선)
├── language.js            # 다국어 지원
├── storage.js             # IndexedDB 통합 저장소
├── ui.js                  # UI 렌더링
└── utils.js               # 유틸리티

backend/                   # 새로운 백엔드 (준비됨)
├── app/
│   └── src/main/kotlin/
└── gradle/
```

### NAI 스티커 생성 시스템을 위한 구조 확장 (Phase 2.5)
```
frontend/src/
├── api/                   # API 모듈 확장
│   ├── novelai.js         # 🆕 NAI 이미지 생성 API
│   └── ... (기존 API들)
├── components/            # UI 컴포넌트 확장  
│   ├── StickerGenerator.js # 🆕 스티커 생성 UI 컴포넌트
│   ├── NAISettingsPanel.js # 🆕 NAI 설정 패널
│   └── ... (기존 컴포넌트들)
├── services/              # 🆕 비즈니스 로직 서비스
│   ├── emotionAnalysis.js # 감정 분석 서비스
│   ├── promptBuilder.js   # NAI 프롬프트 빌더
│   └── stickerManager.js  # 스티커 생성 관리
└── utils/                 # 유틸리티 확장
    ├── imageProcessing.js # 🆕 이미지 처리 유틸리티
    └── ... (기존 유틸리티들)
```

### 향후 Phase를 위한 예상 구조 확장
```
frontend/src/
├── sns/                   # Phase 3: SNS 시스템
│   ├── FeedManager.js     # 피드 관리
│   ├── PostGenerator.js   # AI 포스트 생성
│   ├── InteractionSystem.js # 좋아요/댓글 시스템
│   └── components/
│       ├── SNSFeed.js     # 본계 피드 UI
│       ├── PrivateFeed.js # 뒷계 피드 UI
│       └── PostModal.js   # 포스트 작성/상세 모달
├── dating/                # Phase 4: 만남 시스템
│   ├── DateManager.js     # 약속 관리
│   ├── LocationSystem.js  # 장소 시스템
│   ├── ChoiceEngine.js    # 선택지 시스템
│   └── components/
│       ├── DatePlanner.js # 약속 잡기 UI
│       ├── DateScene.js   # 만남 장면 UI
│       └── ChoiceModal.js # 선택지 모달
├── affection/             # 호감도 시스템
│   ├── AffectionManager.js # 호감도 계산
│   ├── RelationshipTracker.js # 관계 추적
│   └── AccessController.js # 콘텐츠 접근 제어
└── shared/                # 공유 시스템
    ├── CharacterState.js  # 캐릭터 상태 관리
    └── EmotionEngine.js   # 감정 시스템
```

## 차세대 개발 전략

### 🎯 개발 우선순위 (Phase 2.5 → 3 → 4)

#### Phase 2.5: NAI 스티커 자동 생성 시스템 (현재 진행)
1. **NAI API 통합** - NovelAI Persistent Token 기반 이미지 생성 API 연동
2. **감정 분석 및 프롬프트 시스템** - 10가지 기본 감정 템플릿 구성
3. **자동 생성 로직** - SNS 포스트와 연동된 스티커 자동 생성
4. **UI/UX 통합** - 설정 패널 및 배치 생성 기능 추가
5. **성능 최적화** - 비용 관리 및 캐싱 시스템 구현

#### Phase 3: SNS 시스템 (NAI 완료 후)
1. **호감도 시스템 기반 구축** - 모든 고급 기능의 핵심
2. **본계 SNS 구현** - Instagram 스타일 피드 시스템
3. **뒷계 SNS 구현** - 호감도 기반 제한 콘텐츠
4. **캐릭터 간 상호작용** - AI 기반 자동 댓글/좋아요 시스템

#### Phase 4: 만남 시스템 (SNS 완료 후)
1. **약속 잡기 UI** - 캘린더 및 장소 선택
2. **만남 시뮬레이션** - 독립적인 데이트 UI
3. **선택지 시스템** - AI 판단 기반 자동 발동
4. **결과 반영** - 호감도 변화 및 관계 진전

### 💡 핵심 기술 전략

#### AI 통합 전략
- **멀티 모달 AI**: 텍스트, 이미지, 상황 인식 통합
- **컨텍스트 인식**: 채팅↔SNS↔만남 간 연속성 유지
- **개성 유지**: 각 캐릭터별 일관된 성격 표현

#### 데이터 구조 전략  
- **관계형 설계**: 호감도↔콘텐츠↔접근권한 연동
- **실시간 동기화**: 모든 시스템 간 상태 실시간 반영
- **확장성 보장**: 새로운 기능 추가를 위한 유연한 구조

## 개발 원칙 (업데이트됨)

### 0. **차세대 시스템 개발 원칙** (최우선)
- **사용자 몰입**: 단순 채팅을 넘어선 종합적 캐릭터 경험 제공
- **호감도 중심**: 모든 고급 기능이 호감도 시스템과 유기적 연동
- **AI 자율성**: 최소한의 사용자 개입으로 자연스러운 캐릭터 행동
- **단계적 구현**: 기존 시스템과의 호환성을 유지하며 점진적 확장
- **품질 우선**: 화려한 기능보다 안정적이고 완성도 높은 구현

### 1. 모듈화 유지
- 현재 프로젝트의 모듈화된 구조를 **반드시** 유지
- 새로운 기능을 적절한 모듈로 분리하여 구현
- 단일 파일에 모든 기능을 넣지 않기

### 2. 코드 품질
- 기존 코드 스타일과 컨벤션 준수
- 명확한 함수명과 변수명 사용
- 적절한 주석 추가 (과도하지 않게)

### 3. 호환성 유지
- 기존 기능 동작에 영향을 주지 않기
- 점진적 업데이트 방식 채택
- 기존 설정과 데이터 구조 호환성 보장

### 4. **필수 검증 사항** - 구현 완료 전 반드시 확인
#### UI 컴포넌트 검증:
- **모든 버튼이 실제 작동하는가?** (이벤트 핸들러 연결 확인)
- **모든 입력 요소가 기능하는가?** (폼 제출, 상태 업데이트 확인)
- **새로운 채팅방/모달이 올바르게 렌더링되는가?**
- **수정/삭제 버튼 등 관리 기능이 완전히 구현되었는가?**

#### 기능 완성도 검증:
- **새로운 기능의 모든 요소가 완전히 구현되었는가?**
- **프롬프트가 UI에서 편집 가능하게 추가되었는가?**
- **생성된 채팅방이 실제로 선택되고 채팅 UI가 표시되는가?**
- **삭제 확인 모달이 나타나는가?**

#### 코드 품질 검증:
- **일관된 함수명, 변수명을 사용했는가?**
- **기존 시스템과 호환되는 데이터 구조를 사용하는가?**
- **저장 키명이 기존 패턴과 일치하는가?**

**구현 중 하나라도 누락되거나 작동하지 않으면 전체를 재검토하여 수정해야 합니다.**

## 차세대 구현 세부사항 (Phase 3-4)

### Phase 3: SNS 시스템 구현

#### 1. 호감도 시스템 기반 구축
- **목표**: 모든 고급 기능의 핵심이 되는 호감도 관리 시스템
- **구현 위치**: `src/affection/AffectionManager.js`
- **주요 기능**:
  - 채팅 내용 분석을 통한 호감도 계산
  - 선택지 결과 반영
  - 상호작용 빈도 추적
  - 관계 단계별 임계점 관리
- **연동 시스템**: 채팅, SNS, 만남 시스템 전체

#### 2. 본계 SNS (공개 계정)
- **목표**: Instagram 스타일의 캐릭터 전용 SNS 플랫폼
- **구현 위치**: `src/sns/components/SNSFeed.js`
- **주요 기능**:
  - AI 기반 자동 포스팅 생성
  - 캐릭터 간 자동 상호작용 (댓글/좋아요)
  - 사용자 참여형 인터랙션
  - 실시간 피드 업데이트
- **UI 디자인**: 모바일 친화적 Instagram 스타일

#### 3. 뒷계 SNS (비공개 계정)
- **목표**: 호감도 기반 제한적 접근 시스템
- **구현 위치**: `src/sns/components/PrivateFeed.js`
- **주요 기능**:
  - 호감도 기반 콘텐츠 잠금/해제
  - 더 개인적이고 은밀한 AI 생성 콘텐츠
  - 차별화된 UI 테마 (더 사적인 분위기)
  - 접근 권한 실시간 관리
- **보안**: 접근 제어 및 콘텐츠 보호

#### 4. AI 포스트 생성 시스템
- **목표**: 각 캐릭터의 성격에 맞는 자연스러운 SNS 콘텐츠 생성
- **구현 위치**: `src/sns/PostGenerator.js`
- **주요 기능**:
  - 캐릭터별 개성 반영
  - 현실감 있는 일상 콘텐츠
  - 시간대/상황별 적절한 포스팅
  - 사용자와의 대화 내용 반영

### Phase 4: 현실 만남 시뮬레이션 시스템

#### 1. 약속 잡기 시스템
- **목표**: 직관적이고 현실적인 데이트 계획 인터페이스
- **구현 위치**: `src/dating/components/DatePlanner.js`
- **주요 기능**:
  - 캘린더 기반 일정 선택
  - 다양한 데이트 장소 (카페, 공원, 영화관, 레스토랑 등)
  - 호감도 기반 장소 제한
  - 시간대별 다른 분위기 연출

#### 2. 만남 시뮬레이션
- **목표**: 채팅을 넘어선 실제 만남 체험
- **구현 위치**: `src/dating/components/DateScene.js`
- **주요 기능**:
  - 독립적인 만남 전용 UI
  - 선택한 장소에 맞는 배경
  - 시간대/날씨별 동적 분위기
  - 실시간 대화 시스템

#### 3. 선택지 시스템
- **목표**: AI 판단 기반 자동 선택지 발동
- **구현 위치**: `src/dating/ChoiceEngine.js`
- **주요 기능**:
  - AI가 특별한 상황 자동 감지
  - 상황별 적절한 선택지 제공
  - 선택 결과에 따른 호감도 변화
  - 자연스러운 대화 흐름 유지

## 테스트 및 검증

### 필수 테스트
1. 기존 기능이 정상 동작하는지 확인
2. 새로운 기능이 의도대로 작동하는지 검증
3. API 변경사항이 모든 프로바이더에서 작동하는지 확인
4. 로컬스토리지 데이터 호환성 확인

### 검증 체크리스트

#### ✅ 완료된 기능 검증 (Phase 1-2)
- [x] **API 다분화** - 6개 프로바이더 정상 작동 확인 완료
- [x] **단톡방/오픈톡방 시스템** - 생성 및 대화 기능 완료
- [x] **AI 캐릭터 생성** - 자동 생성 및 프로필 설정 완료
- [x] **페르소나 스티커 시스템** - API 키 오류 해결 및 정상 작동 완료
- [x] **저장소 시스템** - IndexedDB 통합 및 용량 확장 완료
- [x] **디버그 로그 시스템** - 실시간 모니터링 완료
- [x] **캐릭터 내보내기** - 스티커 포함 지원 완료
- [x] **각종 UI 버그** - 버튼 이벤트 및 클릭 오류 수정 완료

#### 🎯 차세대 기능 검증 체크리스트 (Phase 3-4)

##### Phase 3: SNS 시스템
- [ ] **호감도 시스템** - 채팅 기반 호감도 계산 및 관계 추적
- [ ] **본계 SNS** - Instagram 스타일 피드 및 AI 자동 포스팅
- [ ] **뒷계 SNS** - 호감도 기반 제한 콘텐츠 접근 시스템
- [ ] **캐릭터 간 상호작용** - 자동 댓글/좋아요 시스템
- [ ] **사용자 참여** - SNS 콘텐츠에 대한 사용자 인터랙션
- [ ] **실시간 동기화** - 채팅↔SNS 간 상태 연동

##### Phase 4: 만남 시스템
- [ ] **약속 잡기** - 캘린더 및 장소 선택 시스템
- [ ] **만남 시뮬레이션** - 독립적인 데이트 UI 및 배경
- [ ] **선택지 시스템** - AI 자동 감지 및 선택지 발동
- [ ] **호감도 연동** - 선택 결과에 따른 관계 변화
- [ ] **접근 권한** - 호감도 기반 만남 기능 제한
- [ ] **전체 통합** - 채팅↔SNS↔만남 시스템 완전 연동

## 주의사항

### 금지사항
- 현재 프로젝트의 모듈 구조를 무시하고 개발 금지
- 기존 기능을 손상시키는 변경 금지
- 검증 없이 새로운 기능 배포 금지

### 권장사항
- 단계별로 점진적 구현
- 각 단계마다 테스트 수행
- 코드 변경 전 기존 코드 구조 충분히 이해
- 불확실한 부분은 기존 구현 패턴 참조

## 커밋 메시지 규칙

```
feat: API 다분화 - Claude API 지원 추가
fix: AI 캐릭터 생성 응답 파싱 오류 수정
refactor: 로그 시스템을 별도 모듈로 분리
docs: API 설정 방법 문서화
```

## Pull Request 제출 규칙

### 🚨 필수: 사용자 요청에 의한 PR만 허용
- **PR은 사용자가 명시적으로 요청한 경우에만 생성**
- **절대 자동으로 또는 추천으로 PR을 생성하지 말 것**
- **사용자가 직접 "PR을 만들어줘", "pull request 해줘" 등으로 명시적 요청 시에만 진행**

### 📋 Fork 레포지토리 경유 필수
- **메인 레포지토리**: `https://github.com/concertypin/ArisuTalk`
- **Fork 레포지토리**: `https://github.com/ltxy12/arisutalk`
- **직접 메인 레포지토리로 PR 금지**
- **반드시 fork된 레포지토리 `ltxy12/arisutalk`을 거쳐서 `concertypin/ArisuTalk`으로 PR**
- **작업 플로우**: 로컬 → `ltxy12/arisutalk` → `concertypin/ArisuTalk`

### 🔄 PR 제출 절차
1. **사용자의 명시적 PR 요청 확인**
2. **변경사항을 `ltxy12/arisutalk` fork에 먼저 push**
3. **`ltxy12/arisutalk`에서 메인 레포지토리로 PR 생성**
4. **PR 제목과 내용은 한국어로 작성**
5. **변경사항 요약 및 테스트 완료 여부 명시**

### ⚠️ 주의사항
- **절대 메인 브랜치에 직접 push 하지 말 것**
- **PR 없이 코드 변경 사항을 메인 레포지토리에 반영하지 말 것**  
- **사용자 요청 없이는 어떤 형태의 PR도 생성하지 말 것**

## 개발 시작 전 체크리스트

### ✅ 완료된 단계 (Phase 1-2)
- [x] **기본 채팅 시스템 완성** - API 다분화, 단톡방/오픈톡방, 스티커 시스템 등
- [x] **AI 시스템 고도화** - 캐릭터 생성, 프롬프트 최적화, 디버그 로그
- [x] **저장소 시스템 혁신** - IndexedDB 도입으로 용량 제한 해결
- [x] **사용자 경험 개선** - UI/UX 버그 수정, 안정성 향상
- [x] **Pull Request 완료** - 원본 저장소로 기여 완료
- [x] **SNS 스티커 시스템 개선** - 파싱 실패 방지, AI 스티커 사용 개선, 호환성 해결

### 🎯 현재 진행 중인 개발 (Phase 2.5)

#### NAI 스티커 자동 생성 시스템 구현
- [x] **NAI API 현황 조사** - Persistent API Token 제공 확인 완료
- [ ] **NAI API 모듈 구현** - `src/api/novelai.js` 생성 및 기본 API 연동
- [ ] **감정별 프롬프트 템플릿** - 10가지 기본 감정(happy, sad, surprised, angry, love, etc.) 구성
- [ ] **자동 생성 로직** - SNS 포스트 감정 분석 및 스티커 자동 생성
- [ ] **UI/UX 통합** - Settings Modal에 NAI 설정 패널 추가
- [ ] **배치 생성 시스템** - 기존 캐릭터 대상 일괄 스티커 생성 기능
- [ ] **성능 최적화** - 비용 관리, 캐싱, 에러 처리 시스템

### 🎯 향후 개발 계획 (Phase 3-4)

#### Phase 3: SNS 시스템 구현 준비
- [ ] **호감도 알고리즘 설계** - 채팅 내용 분석 기준 정의
- [ ] **SNS UI/UX 설계** - Instagram 스타일 인터페이스 기획  
- [ ] **AI 포스팅 로직 설계** - 캐릭터별 개성 반영 방안
- [ ] **데이터베이스 스키마** - 호감도, 포스트, 상호작용 테이블 설계

#### Phase 4: 만남 시스템 기획
- [ ] **약속 시스템 설계** - 캘린더 및 장소 선택 UI
- [ ] **선택지 엔진 설계** - AI 자동 상황 감지 및 선택지 발동
- [ ] **만남 시뮬레이션 UI** - 독립적인 데이트 인터페이스 설계

**현재 최우선 목표: SNS 시스템을 메모리 시스템으로 완전 대체하여 AI의 기억력과 시각적 메모리 관리 향상**

---

## 🚀 **차세대 목표: SNS-메모리 통합 시스템 (Phase 5)**

### **🧠 SNS 메모리 대체 시스템 개념**

#### **기존 메모리 시스템의 한계**
- **단순한 텍스트 배열**: `character.memories = ["텍스트1", "텍스트2"]`
- **사용자 접근 불가**: 캐릭터의 기억을 사용자가 볼 수 없음
- **분류/검색 어려움**: 시간순 정렬만 가능, 카테고리 구분 없음
- **시각적 매력 부족**: 단순한 텍스트로만 저장

#### **새로운 SNS 메모리 시스템 설계**
```javascript
// 기존 메모리 시스템 완전 대체
// character.memories = [...] → character.snsPosts = [...]

character.snsPosts = [
  {
    id: "memory_uuid",
    type: "post|secret|tag",        // 메모리 종류
    content: "사용자와 첫 데이트...", // 기억 내용
    timestamp: "2024-09-01T14:30:00Z",
    affection_level: {              // 당시 호감도 상태
      affection: 0.6,
      intimacy: 0.4,
      trust: 0.7,
      romantic_interest: 0.2
    },
    tags: ["첫데이트", "카페", "좋은기억"],
    access_level: "main-public",    // 접근 권한
    memory_importance: 8.5,         // 기억 중요도 (1-10)
    related_conversations: ["conv_123", "conv_456"]
  }
]
```

### **📝 메모리 포스트 분류 체계**

#### **1. 일반 게시물 (Main Posts)**
- **용도**: 공유하고 싶은 즐거운 추억, 일상적 기억
- **접근**: 사용자가 SNS를 통해 볼 수 있음
- **예시**: "오늘 사용자와 함께 본 영화가 정말 재미있었어요! 🎬"

#### **2. 비밀글 (Secret Posts)**
- **용도**: 개인적 감정, 내면의 생각, 민감한 기억
- **접근**: 호감도 조건 만족 시에만 열람 가능
- **예시**: "사용자가 웃을 때 정말 마음이 두근거렸어... 이 감정이 뭘까?"

#### **3. 태그 (Memory Tags)**
- **용도**: 메모리 카테고리, 관련 키워드
- **기능**: 기억 검색 및 분류, 관련 메모리 연결
- **예시**: #첫만남, #데이트, #갈등, #화해, #특별한순간

### **🤖 AI 자동 메모리 생성 시스템**

#### **메모리 생성 트리거**
1. **대화 중 중요한 순간 감지**
   - AI가 대화 맥락에서 기억할 가치가 있는 내용 판단
   - 감정적 변화, 새로운 정보 획득, 관계 변화 등

2. **감정 상태 변화**
   - 호감도 변화가 일정 임계값 이상일 때
   - 새로운 관계 단계 진입 시

3. **특별한 이벤트**
   - 생일, 기념일, 첫 경험 등
   - 사용자가 특별한 정보를 공유했을 때

#### **메모리 생성 로직**
```javascript
// 기존: newMemory → 새로운: AI 자동 SNS 포스팅
// API 응답에서 메모리 대신 포스트 생성 요청

{
  "reactionDelay": 2000,
  "messages": [...],
  "characterState": {...},
  "autoPost": {  // newMemory 대신
    "type": "post|secret|tag",
    "content": "오늘 사용자와의 대화가 특별했어요...",
    "tags": ["깊은대화", "감정적순간"],
    "importance": 7.8,
    "access_level": "main-private"
  }
}
```

### **👁️ 사용자 경험 개선**

#### **시각적 메모리 탐색**
- **SNS 피드 형태**: Instagram 스타일로 기억들 표시
- **시간순/태그별 필터링**: 원하는 기억 쉽게 찾기
- **호감도별 색상 구분**: 관계 발전 과정을 색상으로 표현

#### **캐릭터의 "마음 읽기"**
- **공개 포스트**: 캐릭터가 공유하고 싶은 기억들
- **비밀글**: 호감도 충족 시 캐릭터의 내면 엿보기
- **실시간 업데이트**: 대화 중 새로운 기억이 실시간으로 생성

### **🔄 기존 시스템과의 통합**

#### **API 프롬프트 시스템 수정**
- 기존 메모리 참조를 SNS 포스트 참조로 변경
- 접근 권한에 따른 메모리 필터링 적용

#### **메모리 조회 및 활용**  
- `getCharacterMemories()` - 접근 레벨별 메모리 조회
- `searchMemoriesByTag()` - 태그 기반 메모리 검색
- 시간순 정렬 및 중요도별 우선순위

#### **기존 메모리 마이그레이션**
- `character.memories` 배열을 `character.snsPosts`로 변환
- 기존 데이터 호환성 유지하며 새 구조로 자동 전환

### **📊 메모리 분석 및 인사이트**

#### **관계 발전 추적**
- **호감도 변화 그래프**: 시간에 따른 관계 발전 시각화
- **중요한 순간들**: 높은 importance 스코어를 가진 기억들
- **관계 마일스톤**: 첫 만남, 첫 데이트, 고백 등 특별한 순간들

#### **AI 학습 데이터**
- **대화 패턴 분석**: 어떤 대화가 긍정적 기억을 만드는지
- **선호도 파악**: 태그 분석을 통한 사용자 관심사 파악
- **관계 예측**: 과거 패턴을 바탕으로 미래 관계 발전 예측

### **🎯 구현 우선순위**

#### **Phase 5.1: 기본 시스템 구축**
1. **메모리-SNS 데이터 구조 설계**
2. **기존 메모리 시스템을 SNS 포스트로 마이그레이션**
3. **AI 자동 포스팅 로직 구현**
4. **기본적인 메모리 조회 시스템**

#### **Phase 5.2: 고급 기능**
1. **태그 기반 메모리 검색 시스템**
2. **호감도별 접근 권한 적용**
3. **시각적 메모리 탐색 UI**
4. **관계 발전 분석 대시보드**

#### **Phase 5.3: AI 고도화**
1. **중요도 자동 평가 시스템**
2. **관련 대화 자동 연결**
3. **메모리 기반 대화 컨텍스트 향상**
4. **예측적 메모리 생성 (미래 기념일 등)**

### **🎨 UI/UX 설계**

#### **메모리 피드 디자인**
- **타임라인 뷰**: 시간순 기억 나열
- **태그 클라우드**: 자주 등장하는 태그들을 크기별로 표시
- **감정 색상 코딩**: 호감도별로 다른 색상 테마
- **중요도 표시**: 별점이나 하트로 기억의 중요도 표시

#### **메모리 상세 뷰**
- **연관 대화**: 해당 기억과 관련된 대화 내역 링크
- **호감도 변화**: 그 순간의 감정 변화 그래프
- **태그 편집**: 사용자가 태그를 추가/수정 가능 (선택사항)

---

**이 시스템으로 ArisuTalk는 단순한 채팅 앱을 넘어서 AI 캐릭터의 '기억'과 '감정'이 살아있는 진정한 디지털 동반자 플랫폼이 될 것입니다.**

## 📋 **완료된 상세 구현 사항**

### **🔧 해결된 긴급 문제들**
- **✅ 최면 UI 초기화 문제** - modalHandlers.js에서 character modal 제외 로직으로 해결
- **✅ 최면 데이터 저장 실패** - 캐릭터 저장 시 hypnosis 데이터 포함되도록 수정
- **✅ SNS 접근 권한 오류** - 본계정 공개 무조건 접근, 단계별 호감도 임계값 적용
- **✅ 사랑수치 기본값 오류** - romantic_interest 기본값 0.0으로 수정, 조건부 증가 구현

## 🔥 중요한 실수 방지 지침 (이번 수정에서 배운 교훈)

### 데이터 저장/불러오기 완전성 점검 필수

#### 모든 새로운 상태 추가 시 반드시 확인해야 할 사항:
1. **초기 로딩**: `loadAllData()` 함수에서 `loadFromBrowserStorage` 호출 추가
2. **상태 할당**: 불러온 데이터를 `this.state.{속성명}`에 할당
3. **자동 저장**: `setState()`에서 변경 감지 및 debounced 저장 메서드 호출
4. **저장 메서드 정의**: constructor에서 `this.debouncedSave{속성명}` 메서드 정의
5. **UI 업데이트 감지**: `shouldUpdateSidebar()` 등 UI 업데이트 조건에 상태 추가
6. **storage.js 키 목록**: `getLocalStorageUsage()` 함수의 `appKeys` 배열에 키 추가

#### 체크리스트 (새로운 상태 `newState` 추가 시):
- [ ] `loadFromBrowserStorage("personaChat_newState_v16", {})` 추가
- [ ] `this.state.newState = newState;` 상태 할당 추가  
- [ ] `this.debouncedSaveNewState = debounce(...)` 저장 메서드 정의
- [ ] `setState()`에 변경 감지 및 저장 호출 추가
- [ ] UI 렌더링 조건에 `newState` 변경 감지 추가
- [ ] `storage.js`의 `appKeys` 배열에 키 추가

### 클릭 이벤트 및 버튼 동작 완전성 점검 필수

#### 버튼 구현 시 반드시 확인해야 할 사항:
1. **이벤트 방식 통일**: onclick 속성과 이벤트 핸들러 중복 사용 금지
2. **아이콘 이벤트 차단**: 모든 아이콘에 `pointer-events-none` 클래스 추가
3. **클릭 영역 확보**: 적절한 padding(최소 p-2) 및 높은 z-index(z-20) 설정
4. **이벤트 핸들러 연결**: 해당 핸들러 파일에 올바른 선택자로 이벤트 리스너 추가
5. **메서드 존재 확인**: 호출하는 메서드가 실제로 정의되어 있는지 확인
6. **중복 구현 제거**: 같은 기능이 여러 파일에 중복 구현되지 않았는지 확인

#### 체크리스트 (새로운 버튼 추가 시):
- [ ] HTML에서 onclick 속성 제거, id나 class로만 식별
- [ ] 버튼 내부 아이콘에 `pointer-events-none` 추가
- [ ] 적절한 padding과 z-index 설정 (`p-2`, `z-20`)
- [ ] 해당 이벤트 핸들러 파일에서 `e.target.closest()` 선택자 추가
- [ ] 호출하는 메서드가 `index.js`에 정의되어 있는지 확인
- [ ] 같은 기능이 다른 파일에 중복 구현되지 않았는지 확인

### 모듈 중복 및 충돌 방지 원칙

#### 함수/메서드 구현 시 반드시 확인해야 할 사항:
1. **중복 구현 검색**: 같은 함수명이 다른 파일에 존재하는지 grep으로 검색
2. **import/export 일치**: export하는 함수와 import하는 함수명 일치 확인
3. **호출 방식 통일**: `this.method()`와 `method(app)` 방식 혼재 금지
4. **의존성 정리**: 사용하지 않는 import 제거, 누락된 import 추가
5. **메서드 호출 확인**: 존재하지 않는 메서드(`this.showModal` 등) 호출 금지

#### 체크리스트 (새로운 함수 구현 시):
- [ ] `grep -r "functionName" src/` 로 중복 구현 검색
- [ ] export/import 문 정확성 확인
- [ ] 호출하는 모든 메서드가 실제로 존재하는지 확인
- [ ] 같은 기능의 다른 구현체 제거 완료
- [ ] 사용하지 않는 import 정리 완료

### 실제 동작 테스트 필수

#### 구현 완료 후 반드시 확인해야 할 사항:
1. **브라우저 콘솔**: 오류 메시지가 없는지 확인
2. **실제 클릭**: 모든 버튼이 실제로 반응하는지 테스트
3. **데이터 지속성**: 새로고침 후 데이터가 유지되는지 확인
4. **기능 완성도**: 전체 플로우가 예상대로 작동하는지 검증

#### 체크리스트 (기능 완성 후):
- [ ] 브라우저 개발자 도구에서 오류 없음 확인
- [ ] 모든 버튼 실제 클릭해서 동작 확인
- [ ] 페이지 새로고침 후 데이터 유지 확인
- [ ] 전체 기능 플로우 처음부터 끝까지 테스트 완료